package com.malware.application.cache;

import org.infinispan.manager.EmbeddedCacheManager;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

/**
 * This class wraps the Infinispan API for a mapping between TID, SID, and ProcessInstanceId
 */
@Service("id-mapping-cache")
public class IdMappingCache {

    private static final Logger log = LoggerFactory.getLogger(IdMappingCache.class);

    private static final String CACHE_NAME = "processIdCache";
    private final EmbeddedCacheManager cacheManager;

    @Autowired
    public IdMappingCache(EmbeddedCacheManager cacheManager) {
        this.cacheManager = cacheManager;
    }

    /**
     * Publish a process id mapping to the cache
     * @param processId the process instance id
     * @param sId the submission ID
     * @param tId the transaction ID
     */
    public void publishKeymap(long processId, String tId, String sId) {
        ProcessIdMapping mapping = new ProcessIdMapping( processId, tId, sId );
        cacheManager.getCache(CACHE_NAME).put(mapping.getGeneratedKey(), mapping);
    }

    /**
     * Load a process id mapping from a sid & tid
     * @param sid the sid
     * @param tid the tid
     * @return the relevant process instance ID or {@code null} if it does not exist in the cache
     */
    public ProcessIdMapping getMappedValues(String sid, String tid) {
        String key = ProcessIdMapping.generateIdKey(sid, tid);
        return (ProcessIdMapping) cacheManager.getCache(CACHE_NAME).getOrDefault(key, null);

    }

    /**
     * Delete a process instance ID from the cache
     * @param sid the sid
     * @param tid the tid
     * @return {@code true} if an item was removed, otherwise {@code false}
     */
    public boolean deleteProcessMapping(String sid, String tid) {
//        System.out.println("id = " + processInstanceId );
        String key = ProcessIdMapping.generateIdKey(sid, tid);

        // This is not removing from the persistent store for some reason. TODO: Investigate
        Object o = cacheManager.getCache(CACHE_NAME).remove(key);
        return o != null;
    }

}
