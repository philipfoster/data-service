package com.malware.application;

import com.malware.application.camel.Iso8601ToMySqlTimestampProcessor;
import org.apache.camel.ExchangePattern;
import org.apache.camel.builder.RouteBuilder;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * Camel Route Builder for exposing REST API endpoints and handling data transformation
 * h_ naming convention used to indicate exchange header parameter
 * 
 * @author Nevin Zhu
 * @version 1.0
 * @since 2020-5-7
 *
 */
@Configuration
public class DataServiceAutoConfiguration {

	@Value("${trace.event.queue}")
	private String processEventsQueue;

	@Bean
    public RouteBuilder routeBuilder() {
        return new RouteBuilder() {
            @Override
            public void configure() throws Exception {
            	/*
            	 *  REST endpoints definition
            	 */
                rest("/data")
                    .post("/srecord/{h_sid}").to("direct:build-submission-record")
                    .post("/mfile/{h_tid}").to("direct:build-move-file")
                    .post("/hfile").to("direct:build-hash-file")
                    .post("/metadata/{h_tid}").to("direct:build-metadata")
                    .post("/nsrl").to("direct:build-nsrl-lookup")
                    .post("/trecord/{h_sid}/{h_tid}/{h_level}/{h_submission_id}").to("direct:build-transaction-record")
                    .post("/unzip").to("direct:build-unzip")
                    .post("/hashseen").to("direct:build-hashseen")
                    .post("/split/submissionfiles/{h_sid}/{h_submissionId}").to("direct:split-submission-files")
                    .post("/split/unzipfiles/{h_level}/{h_sid}/{h_submissionId}").to("direct:split-unzipped-files")
                    .post("/send/{h_destination}/{h_level}/{h_sid}/{h_tid}").to("direct:send-to-msgbroker")
					.post("/idcache").to("direct:idcache-insert-route")
					.get("/lookupProcess/{h_sid}/{h_tid}").to("direct:lookup-processInstanceId")
					.post("/scanresult").to("direct:scan-result")
					.post("/magicresult").to("direct:process-magic")
					.put("/trecord/{h_sid}/{h_tid}").to("direct:update-trecord");

                from("direct:update-trecord").id("update-trecord")
					.log("updating trecord; body = ${body}")
					.setHeader("h_submission_id", jsonpath("submission.submission_id"))
					// sid (from url params)
					// tid (from url params)
					.setHeader("h_malicious_archive_ind", constant("N")) // TODO: Find where this comes from. Hard coding for now
					.setHeader("h_transaction_file_id", jsonpath("t_record[0].result.transaction_file_id"))
					.setHeader("h_level", jsonpath("level"))
					.setHeader("h_location", jsonpath("t_record[0].result.location"))
					.setHeader("h_name", jsonpath("t_record[0].result.name"))
					.setHeader("h_magic_num", jsonpath("magic.files[0].magicNumber"))
					.setHeader("h_file_extension", jsonpath("magic.files[0].magicType"))
					.setHeader("h_file_metadata_id", jsonpath("metadata[0].result.file_metadata_id"))
					.setHeader("h_original_file_name", jsonpath("move_file.file_info[0].original_file_name"))
					.choice()
					    // If archive file, PID is the same as TID, else null
						//
						// If file is an archive, the magicType *should* contain the substring "archive"
						.when(jsonpath("magic.files[0].magicType").contains("archive"))
							.setHeader("h_pid", header("tid"))
						.otherwise()
							.setHeader("h_pid", constant(null))
					.end()
					.choice()
						.when(jsonpath("hash_seen[0].message").isEqualToIgnoreCase("Record found"))
							.setHeader("h_hash_exist_ind", constant("Y"))
						.otherwise()
							.setHeader("h_hash_exist_ind", constant("N"))
					.end()
					.setHeader("h_size", constant("1 meg"))
					.choice()
						.when(jsonpath("nsrl_lookup.messages[0]").isEqualToIgnoreCase("hash does not exist"))
							.setHeader("h_nsrl_ind", constant("N"))
						.otherwise()
							.setHeader("h_nsrl_ind", constant("Y"))
					.end()
					.to("freemarker:templates/update_tx_record_resp.ftl")
					.log("SENDING UPDATED JSON ${body}");
//					.setBody(body().regexReplaceAll("\\r|\\n", ""));

                from("direct:process-magic").id("process-magic")
					.setHeader("h_sid", jsonpath("files[0].sid"))
					.setHeader("h_tid", jsonpath("files[0].tid"))
					.setHeader("body", body()) // temporarily store body so we can restore it later
					.to("bean:id-mapping-cache?method=getMappedValuesAsString(${headers.h_sid}, ${headers.h_tid})")
					.setHeader("h_instance_id", body()) // send the instance id back as a HTTP header
					.setBody(header("body")) // restore body & remove body header from response
					.removeHeader("body");


				/*
				 * Process messages from the malware scan results queue.
				 */
				from("direct:scan-result").id("scan-result")
					.setHeader("h_tid", jsonpath("tid"))
					.setHeader("h_sid", jsonpath("sid"))
					.setHeader("h_engine", jsonpath("analysisEngine"))
					.setHeader("h_result_location", jsonpath("analysisResultLocation"))
					.choice() // determine which engine to send to
						.when(header("h_engine").isEqualTo("NSRL"))
							.setHeader("h_type", constant("Nsrl"))
						.when(header("h_engine").isEqualTo("METADEFENDER"))
							.setHeader("h_type", constant("Static"))
						.when(header("h_engine").isEqualTo("CUCKOO"))
							.setHeader("h_type", constant("Dynamic"))
					.end()
					.to("bean:id-mapping-cache?method=getMappedValuesAsString(${headers.h_sid}, ${headers.h_tid})")
					.setHeader("h_instance_id", body())
					.process( exchange -> {
						exchange.setOut(exchange.getIn());
						String resultLocation = (String) exchange.getOut().getHeader("h_result_location");
						log.info("resultLocation = {}", resultLocation);

						int fileSplitIdx = resultLocation.lastIndexOf('/') + 1;
						exchange.getOut().setHeader("h_filename", resultLocation.substring(fileSplitIdx));
						exchange.getOut().setHeader("h_path", resultLocation.substring(0, fileSplitIdx));
						exchange.getOut().setBody(null);
					})
					.to("freemarker:templates/scan_result.ftl")
					.log("...response built for scan result: ${body}");

                /*
                 * Insert item into ID cache
                 * Parameters:
                 *
                 * Headers:
                 * 		- h_sid = submission id
                 * 		- h_tid = transaction id
                 * 		- h_piid = process instance id
                 */
				from("direct:idcache-insert-route").id("idcache-insert-route")
					.log("Inserting new item into ID cache")
					.setHeader("processId", jsonpath("processId"))
					.setHeader("sId", jsonpath("sId"))
					.setHeader("tId", jsonpath("tId"))
					.to("bean:id-mapping-cache?method=publishKeymap(${headers.processId}, ${headers.tId}, ${headers.sId})");

				/*
				 * Process requests from AMQ
				 */
				from("activemq:"+processEventsQueue+"?transacted=true")
					.to("direct:handle-trace-event");

				/*
				 * Process a message received from an AMQ queue, and push the result to the database.
				 * Example input schema:
				 *
				 * {
				 *   "ProcessInstanceId":"18",
				 *   "TimeStamp":"2020-06-19T15:42:34.131",
				 *   "TraceEventType":"ProcessTraceEvent",
				 *   "EventActionType":"BeforeNodeTriggered",
				 *   "Process":{
				 * 	   "Name":"testprocess",
				 * 	   "Node":{
				 * 	     "StartedOn":"2020-06-19T15:42:34.131",
				 * 	     "CompletedOn":null,
				 * 	     "State":"Completed",
				 * 	     "Name":"end"
				 * 	   }
				 *   }
				 * }
				 *
				 */
				from("direct:handle-trace-event")
					.id("trace-events")
//					.log("Received message from queue ${body}")
					.setHeader("processInstanceId", jsonpath("ProcessInstanceId"))
					.setHeader("eventTimestamp", jsonpath("TimeStamp"))
					.setHeader("traceEventType", jsonpath("TraceEventType"))
					.setHeader("eventActionType", jsonpath("EventActionType"))
					.setHeader("processName", jsonpath("Process.Name"))
					.choice()
						.when(jsonpath("Process.Node").isNotNull())
							.setHeader("nodeState", jsonpath("Process.Node.State"))
							.setHeader("nodeName", jsonpath("Process.Node.Name"))
							.setHeader("nodeStartedOn", jsonpath("Process.Node.StartedOn"))
							.setHeader("nodeCompletedOn", jsonpath("Process.Node.CompletedOn"))
						.otherwise()
							.setHeader("nodeState", constant(null))
							.setHeader("nodeName", constant(null))
							.setHeader("nodeStartedOn", constant(null))
							.setHeader("nodeCompletedOn", constant(null))
					.end()
//					.log("value = ${header.eventTimestamp}")
					.process(new Iso8601ToMySqlTimestampProcessor("nodeStartedOn", "nodeCompletedOn", "eventTimestamp"))
					//language=sql
					.setBody(constant("INSERT INTO process_trace_event (process_instance_id, trace_event_type, process_name, node_name"
						+ ", action_event_type, node_state, event_timestamp, node_started_on, node_completed_on) "
						+ "VALUES (:?processInstanceId, :?traceEventType, :?processName, :?nodeName,"
						+ " :?eventActionType, :?nodeState, :?eventTimestamp, :?nodeStartedOn, :?nodeCompletedOn);"))
					.to("jdbc:datasource?useHeadersAsParameters=true");
//					.to("mock:mockdb");

                /*
                 * Send to message broker. Level attribute is added to the JMS header
                 * h_destination is which queue destination the message will be sent to. Possible values are: 
                 * stage - Send payload directly to the stage queue. This is only used by the split submission record route
                 * dynamic - send payload to the dynamic queue
                 * static - send payload to the static queue
                 * magic - send payload to the magic checker queue
                 * nsrl - send payload to the nsrl queue
                 * 
                 */
                from("direct:send-to-msgbroker").id("send-to-msgbroker")
                .log("...sendin to amq broker. Destination type: ${headers.h_destination} File Level: ${headers.h_level} SID: ${headers.h_sid} SubID: ${headers.h_submissionId} Message Body: ${body}")
                .choice()                			
                  .when(header("h_destination")
                		  .isEqualTo("stage"))
                  			.log("..stage queue for splitted submission files selected")
                  			.setExchangePattern(ExchangePattern.InOnly)
                  			.toD("activemq:{{file.stage.queue}}")
                  			.id("stage-queue-destination")
                  			
                  .when(header("h_destination")
                		  .isEqualTo("dynamic"))
                  			.log("..dynamic queue selected")
                  			.to("direct:build-dynamic-analysis-engine")
                  			.setExchangePattern(ExchangePattern.InOnly)
                  			.toD("activemq:{{dynamic.analysis.queue}}")
                  			.id("dynamic-analysis-queue-destination")
                  			
                  .when(header("h_destination")
                		  .isEqualTo("static"))
                  			.log("..static queue selected")
                  			.to("direct:build-static-analysis-engine")
                  			.setExchangePattern(ExchangePattern.InOnly)
                  			.toD("activemq:{{static.analysis.queue}}")
                  			.id("static-analysis-queue-destination")
                  			
                  .when(header("h_destination")
                		  .isEqualTo("magic"))
                  			.log("..magic queue selected")
                  			.to("direct:build-magic-analysis")
                  			.setExchangePattern(ExchangePattern.InOnly)
                  			.toD("activemq:{{magic.analysis.queue}}")
                  			.id("magic-analysis-queue-destination")
                  			
                  .when(header("h_destination")
                		  .isEqualTo("nsrl"))
                  			.log("..nsrl queue selected")
                  			.to("direct:build-nsrl-queue-request")
                  			.setExchangePattern(ExchangePattern.InOnly)
                  			.toD("activemq:{{nsrl.analysis.queue}}")
                  			.id("nsrl-analysis-queue-destination");

                /*
                 * Inbound Data Description: A collection of unzip files from zip microservice
                 * Inbound Data Type: JSON
                 * Accept-Content: text/plain
                 * Method: HTTP-POST
                 * Outbound Data Description: Decomposed unzip files. Sent to the staging message queue
                 */
                from("direct:split-unzipped-files").id("split-unzipped-files")
                .log("Split unzip route triggered. Body is ${body}")
/*                .setHeader("h_fname").jsonpath("submission_data.first_name")
                .setHeader("h_lname").jsonpath("submission_data.last_name")
                .setHeader("h_pnumber").jsonpath("submission_data.phone_number")
                .setHeader("h_org").jsonpath("submission_data.organization")
                .setHeader("h_email").jsonpath("submission_data.email")
                .setHeader("h_ip").jsonpath("submission_data.ip")*/
                .split().jsonpath("file_info[*]").aggregationStrategy(new SubmissionFileAggregateStrategy())
                .log("--> After Split, body is ${body}")
                .setHeader("h_filepath").jsonpath("path")
                .setHeader("h_filename").jsonpath("file_name")
                .to("freemarker:templates/split_unzip_files.ftl")
                .setHeader("h_destination").simple("stage")
                .to("direct:send-to-msgbroker");
                
                /*
                 * Inbound Data Description: A collection of submission files from submission queue
                 * Inbound Data Type: JSON
                 * Accept-Content: text/plain
                 * Method: HTTP-POST
                 * Outbound Data Description: Decomposed submission files. Single file path is returned.
                 */
                from("direct:split-submission-files").id("split-submission-files")
                    .log("Split submission route triggered. Body is ${body}")
/*                    .setHeader("h_fname").jsonpath("submission_data.first_name")
                    .setHeader("h_lname").jsonpath("submission_data.last_name")
                    .setHeader("h_pnumber").jsonpath("submission_data.phone_number")
                    .setHeader("h_org").jsonpath("submission_data.organization")
                    .setHeader("h_email").jsonpath("submission_data.email")
                    .setHeader("h_ip").jsonpath("submission_data.ip")*/
                    .split().jsonpath("file_paths[*]").aggregationStrategy(new SubmissionFileAggregateStrategy())
					.to("freemarker:templates/split_submission_files.ftl")
                    .choice()
                       .when(header("CamelSplitIndex").isGreaterThan(0)).setHeader("h_level").simple("0").setHeader("h_destination").simple("stage").to("direct:send-to-msgbroker");
                
                /*
                 * Inbound Data Description: Raw data from submission queue
                 * Inbound Data Type: JSON
                 * Accept-Content: text/plain
                 * Method: HTTP-POST
                 * Outbound Data Description: JSON request payload for invoking submission record microservice
                 */
                from("direct:build-submission-record").id("build-submission-record")
                    .log("${body}")
                    .setHeader("h_fname").jsonpath("submission_data.first_name")
                    .setHeader("h_lname").jsonpath("submission_data.last_name")
                    .setHeader("h_pnumber").jsonpath("submission_data.phone_number")
                    .setHeader("h_org").jsonpath("submission_data.organization")
                    .setHeader("h_email").jsonpath("submission_data.email")
                    .setHeader("h_ip").jsonpath("submission_data.ip")
                    .setHeader("h_submission_type_cd").jsonpath("submission_data.submission_type_cd")
                    .setHeader("h_description").jsonpath("submission_data.description")
                    .setHeader("h_traffic_light_protocol_cd").jsonpath("submission_data.traffic_light_protocol_cd")
                    .setHeader("h_incident_id").jsonpath("submission_data.incident_id")
                    .setHeader("h_disclaimer_ind").jsonpath("submission_data.disclaimer_ind")
                    .to("freemarker:templates/submission_record_req.ftl")
                    .log("...response built for submission record request: ${body}");

                /*
                 * Inbound Data Description: Raw data from submission queue
                 * Inbound Data Type: JSON
                 * Accept-Content: text/plain
                 * Method: HTTP-POST
                 * Outbound Data Description: JSON request payload for invoking file mover microservice
                 */
                from("direct:build-move-file").id("build-move-file")
                .log("..Received payload from REST API: ${body}")
                .setHeader("h_filepath").jsonpath("file_paths[0]")
                .to("freemarker:templates/move_file_req.ftl")
                .log(".. response built for move file request: ${body}");
                
                /*
                 * Inbound Data Description: JSON response data from file mover microservice
                 * Inbound Data Type: JSON
                 * Accept-Content: text/plain
                 * Method: HTTP-POST
                 * Outbound Data Description: JSON request payload for invoking create hash microservice
                 */
                from("direct:build-hash-file").id("build-hash-file")
                .log("..Received payload from REST API: ${body}")
                .setHeader("h_filepath").jsonpath("file_info[0].path")
                .setHeader("h_filename").jsonpath("file_info[0].new_file_name")
                .to("freemarker:templates/hash_file_req.ftl")
                .log(".. response built for hash file request: ${body}");
                
                /*
                 * Inbound Data Description: JSON response data from create hash microservice
                 * Inbound Data Type: JSON
                 * Accept-Content: text/plain
                 * Method: HTTP-POST
                 * Outbound Data Description: JSON request payload for invoking metadata microservice
                 */
                from("direct:build-metadata").id("build-metadata")
                .log("..Received payload from REST API: ${body}")
                .setHeader("h_md5").jsonpath("results[0].md5")
                .setHeader("h_sha1").jsonpath("results[0].sha1")
                .setHeader("h_sha256").jsonpath("results[0].sha256")
                .setHeader("h_sha512").jsonpath("results[0].sha512")
                .setHeader("h_ssdeep").jsonpath("results[0].ssdeep")
                .to("freemarker:templates/create_metadata_req.ftl")
                .log(".. response built for create metadata request: ${body}");
                
                /*
                 * Inbound Data Description: JSON response data from create hash microservice
                 * Inbound Data Type: JSON
                 * Accept-Content: text/plain
                 * Method: HTTP-POST
                 * Outbound Data Description: JSON request payload for invoking nsrl lookup microservice
                 */
                from("direct:build-nsrl-lookup").id("build-nsrl-lookup")
                .log("..Received payload from REST API: ${body}")
                .setHeader("h_sha1").jsonpath("results[0].sha1")
                .to("freemarker:templates/nsrl_req.ftl")
                .log(".. response built for nsrl request: ${body}");

                /*
                 * Inbound Data Description: Concatenated JSON data from joining submission record response data and file mover response data
                 * Inbound Data Type: JSON
                 * Accept-Content: text/plain
                 * Method: HTTP-POST
                 * Outbound Data Description: JSON request payload for invoking transaction record microservice
                 */
                from("direct:build-transaction-record").id("build-transaction-record")
                .log("..Received payload from REST API: ${body}")
                .setHeader("h_filepath").jsonpath("file_info[0].path")
                .setHeader("h_filename").jsonpath("file_info[0].new_file_name")
                .to("freemarker:templates/transaction_record_req.ftl")
                .log(".. response built for transaction record request: ${body}");
                
                /*
                 * Inbound Data Description: JSON response data from file mover microservice
                 * Inbound Data Type: JSON
                 * Accept-Content: text/plain
                 * Method: HTTP-POST
                 * Outbound Data Description: JSON request payload for invoking unzip microservice
                 */
                from("direct:build-unzip").id("build-unzip")
                .log("..Received payload from REST API: ${body}")
                .setHeader("h_filepath").jsonpath("file_info[0].path")
                .setHeader("h_filename").jsonpath("file_info[0].new_file_name")
                .to("freemarker:templates/unzip_req.ftl")
                .log(".. response built for unzip request: ${body}");
                
                /*
                 * Inbound Data Description: JSON response data from create hash microservice
                 * Inbound Data Type: JSON
                 * Accept-Content: text/plain
                 * Method: HTTP-POST
                 * Outbound Data Description: JSON request payload for invoking hash seen microservice
                 */
                from("direct:build-hashseen").id("build-hashseen")
                .log("..Received payload from REST API: ${body}")
                .setHeader("h_sha256").jsonpath("results[0].sha256")
                .setBody().simple("${header.h_sha256}")
                .log(".. response built for hash seen request: ${body}");

                /*
                 * Inbound Data Description: JSON response data from file mover microservice
                 * Inbound Data Type: JSON
                 * Accept-Content: text/plain
                 * Method: HTTP-POST
                 * Outbound Data Description: JSON request payload for invoking magic analysis engine (message queue)
                 */
                from("direct:build-magic-analysis").id("build-magic-analysis")
                .log("..Received payload from REST API: ${body}")
                .setHeader("h_filepath").jsonpath("file_info[0].path")
                .setHeader("h_filename").jsonpath("file_info[0].new_file_name")
                .to("freemarker:templates/magic_checker_req.ftl")
                .log(".. response built for magic check request: ${body}");
                
                /*
                 * Inbound Data Description: JSON response data from file mover microservice
                 * Inbound Data Type: JSON
                 * Accept-Content: text/plain
                 * Method: HTTP-POST
                 * Outbound Data Description: JSON request payload for invoking static analysis engine (message queue)
                 */
                from("direct:build-static-analysis-engine").id("build-static-analysis-engine")
                .log("..Received payload from REST API: ${body}")
                .setHeader("h_filepath").jsonpath("file_info[0].path")
                .setHeader("h_filename").jsonpath("file_info[0].new_file_name")
                .to("freemarker:templates/static-analysis_engine_req.ftl")
                .log(".. response built for analysis engine request: ${body}");
                
                /*
                 * Inbound Data Description: JSON response data from file mover microservice
                 * Inbound Data Type: JSON
                 * Accept-Content: text/plain
                 * Method: HTTP-POST
                 * Outbound Data Description: JSON request payload for invoking dynamic analysis engine (message queue)
                 */
                from("direct:build-dynamic-analysis-engine").id("build-dynamic-analysis-engine")
                .log("..Received payload from REST API: ${body}")
                .setHeader("h_filepath").jsonpath("file_info[0].path")
                .setHeader("h_filename").jsonpath("file_info[0].new_file_name")
                .to("freemarker:templates/dynamic-analysis_engine_req.ftl")
                .log(".. response built for analysis engine request: ${body}");
                
                /*
                 * Inbound Data Description: JSON response data from file mover microservice
                 * Inbound Data Type: JSON
                 * Accept-Content: text/plain
                 * Method: HTTP-POST
                 * Outbound Data Description: JSON request payload for nsrl queue (message queue)
                 */
                from("direct:build-nsrl-queue-request").id("build-nsrl-queue-request")
                .log("..Received payload from REST API: ${body}")
                .setHeader("h_filepath").jsonpath("file_info[0].path")
                .setHeader("h_filename").jsonpath("file_info[0].new_file_name")
                .to("freemarker:templates/nsrl_queue_request.ftl")
                .log(".. response built for nsrl queue request: ${body}");
            }
        };
    }
}